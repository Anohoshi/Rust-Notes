## Basic Concepts
- В этом части я разберу, почему иногда лучше использовать структуры.
## Explanation
### Мы создадим программу с функцией, которая принимает в себя длины сторон прямоугольника и возвращает  числовое значение.
#### Код:
```Rust
fn main(){
	let mut width_one = 14;
	let mut height_one = 48;  

	println!(
		"The area of the rectangle is {} square pixels.", 
		area(&width_one, &height_one));
}

fn area(width: &u32, height: &u32) ->u32 {
	width * height
}
```
#### Вывод программы:
```

The area of the rectangle is 569106 square pixels.
```
- Этот код успешно вычисляет площадь прямоугольника, но есть проблема. Функция `area` вычисляет два параметра, но сами параметры никак не связаны в коде. Поэтому лучше использовать рефакторинг используя кортеж.
#### Рефакторинг с помощью кортежей:
```Rust
fn main(){
	let rectangle_one = (22, 8);
	
	println!(
		"The area of the rectangle is {} square pixels.",                                 area(&rectangle_one));
}

fn area(rectangle: &(u32, u32)) ->u32 {
	rectangle.0 * rectangle.1
}
```
- С одной стороны программа выглядит лучше и данные стали связаны между собой, но код струднее читать, также у кортежа элементы никак не названы, а просто проиндексированы и не ясно где длина, а где ширина.
- Если бы кто-то другой использовал наш код, то ему бы пришлось держать в уме под какими индексами длина и ширина. 
- Этот код можно исправить создав структуру для прямоугольника.
#### Рефакторинг с помощью структур:
```Rust
struct Rectangle{
	width: u32,
	height: u32
}

fn main(){
	let rectangle_one = Rectangle{
		width: 150,
		height: 300
	};

	println!(
	"The area of the rectangle is {} square pixels.", 
	area(&rectangle_one));
}

fn area(rectangle: &Rectangle) ->u32 {
	rectangle.height * rectangle.width
}
```
- Структуры сделали код лучше, он стал более читаемым, а также они дали смысл данным, теперь ширина и длина это не индекс 0 и индекс 1, а данные с именами.
- Мы определили структуру Rectangle, внутри определили поля как `width` и `height`, затем создали объект в `main` 
### Вывод структуры для отладки
- По дефолту в Rust  не поддерживается форматирование для пользовательских структур при выводе через `println!` из-за того что для них не реализован типаж `Display`, используемый для пользовательского форматирования.
- Для того, чтобы вывести содержимое объекта структуры нужно использовать типаж `Debug`, который нужен для удобного вывода структуры с полной информацией для отладки.
- Чтобы позволить структурам использовать форматирование через `Debug`, нужно явно добавить атрибут `#[derive(Debug)]` перед объявлением структуры.
#### Example:
```Rust
#[derive(Debug)]
struct Rectangle{
	weight: u32,
	height: u32
}

fn main(){
	let rectangle_one = Rectangle{
		weight: 150,
		height: 300
	};

	println!("{:#?}", rectangle_one)
}
```
##### Output with `#` in `println!(":#?")`:
```
Rectangle {
    weight: 150,
    height: 300,
}      
```
##### Output without `#` in `println!(":?")`:
```
Rectangle { weight: 150, height: 300 }
```
#### Также для вывода структуры можно использовать макрос `dbg!()`:
```Rust
#[derive(Debug)]
struct Rectangle{
	weight: u32,
	height: u32
} 

fn main(){
	let rectangle_one = Rectangle{
		weight: 150,
		height: 300
	};

	dbg!(&rectangle_one);
}
```
##### Output:
```Output
[src/main.rs:13:5] &rectangle_one = Rectangle {
    weight: 150,
    height: 300,
}             
```
- Макрос `dbg!()` выводит значение выражения с информацией об исходном месте вызова (файл и строку).
- Также `dbg!()` выводит информацию в стандартный поток ошибок (`stderr`), а не в стандартный поток вывода (`stdout`) как макрос `println!()`.
## Notes
- Макрос `dbg!()` на время забирает владение у структуры, %%я пока хз с чем его еще использовать%% но возвращает его. Если все-таки не хочется передавать владение то можно использовать обычную ссылку `&`. 
## Links
[Ссылка на главу из официальной документации](https://doc.rust-lang.ru/book/ch05-02-example-structs.html)
#ownership #structures #rust_debug